//! Stripe Subscription API
//!
//! This module provides functionality to create, retrieve, update, and cancel subscriptions.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use crate::client::Client;
use crate::error::Result;
use crate::types::{Currency, Id, List, Metadata, Timestamp};

/// A Stripe subscription object
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Subscription {
    /// Unique identifier for the object
    pub id: Id,

    /// String representing the object's type
    pub object: String,

    /// ID of the Connect Application that created the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application: Option<Id>,

    /// A non-negative decimal between 0 and 100 that represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_fee_percent: Option<f64>,

    /// Either `charge_automatically`, or `send_invoice`
    pub billing: BillingType,

    /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_thresholds: Option<SubscriptionBillingThresholds>,

    /// If the subscription has been canceled, the date of that cancellation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canceled_at: Option<Timestamp>,

    /// If the subscription has a `trial_end`, and `cancel_at_period_end` is true, this is set to true
    pub cancel_at_period_end: bool,

    /// If the subscription has been created with `cancel_at_period_end`, the date of that cancellation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancel_at: Option<Timestamp>,

    /// Time at which the object was created
    pub created: Timestamp,

    /// Three-letter ISO currency code
    pub currency: Currency,

    /// End of the current period that the subscription has been invoiced for
    pub current_period_end: Timestamp,

    /// Start of the current period that the subscription has been invoiced for
    pub current_period_start: Timestamp,

    /// ID of the customer who owns the subscription
    pub customer: Id,

    /// Number of days a customer has to pay invoices generated by this subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_until_due: Option<i64>,

    /// ID of the default payment method for the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_payment_method: Option<Id>,

    /// The subscription's description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Subscription items
    pub items: List<SubscriptionItem>,

    /// The most recent invoice for this subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub latest_invoice: Option<Id>,

    /// Has the value true if the object exists in live mode or the value false if the object exists in test mode
    pub livemode: bool,

    /// Set of key-value pairs attached to the object
    #[serde(default)]
    pub metadata: Metadata,

    /// Time at which payment will next be attempted
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_pending_invoice_item_invoice: Option<Timestamp>,

    /// If specified, payment collection for this subscription will be paused
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pause_collection: Option<PauseCollection>,

    /// If the subscription has been canceled with the `at_period_end` flag set to true, `pending_update` indicates whether an update is scheduled once the subscription completes its current period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pending_update: Option<SubscriptionPendingUpdate>,

    /// Hash describing the plan the customer is subscribed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plan: Option<Plan>,

    /// The quantity of the plan to which the customer should be subscribed
    pub quantity: i64,

    /// The schedule attached to the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schedule: Option<Id>,

    /// Date when the subscription was started or will start
    pub start_date: Timestamp,

    /// Describes the current status of the subscription
    pub status: SubscriptionStatus,

    /// If the subscription has a trial, the end of that trial
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trial_end: Option<Timestamp>,

    /// If the subscription has a trial, the beginning of that trial
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trial_start: Option<Timestamp>,
}

/// Either `charge_automatically`, or `send_invoice`
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum BillingType {
    /// Stripe automatically charges the customer when an invoice is created
    ChargeAutomatically,

    /// Stripe emails the customer an invoice that they can pay
    SendInvoice,
}

/// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct SubscriptionBillingThresholds {
    /// Monetary threshold that triggers the subscription to advance to a new billing period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amount_gte: Option<i64>,

    /// Indicates if the `billing_cycle_anchor` should be reset when a threshold is reached
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_billing_cycle_anchor: Option<bool>,
}

/// If specified, payment collection for this subscription will be paused
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct PauseCollection {
    /// The payment collection behavior for this subscription while paused
    pub behavior: PauseCollectionBehavior,

    /// The time after which the subscription will resume collecting payments
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resumes_at: Option<Timestamp>,
}

/// The payment collection behavior for this subscription while paused
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PauseCollectionBehavior {
    /// Continue to generate invoices but do not attempt to collect payment
    KeepAsDraft,

    /// Stop generating invoices
    Void,

    /// Mark the subscription and all associated invoices as uncollectible
    MarkUncollectible,
}

/// Pending updates that will be applied to the subscription once the latest invoice is paid
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct SubscriptionPendingUpdate {
    /// If set, the update will be applied at the end of the subscription's current period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_cycle_anchor: Option<Timestamp>,

    /// Pending cancellation date
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancel_at: Option<Timestamp>,

    /// If set, the subscription will cancel at the end of the current period
    pub cancel_at_period_end: Option<bool>,

    /// Changes to the subscription items
    pub items: Option<Vec<SubscriptionItemUpdateParams>>,

    /// If set, the subscription will reset its billing cycle anchor value to the provided timestamp value
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trial_end: Option<Timestamp>,
}

/// A subscription item
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct SubscriptionItem {
    /// Unique identifier for the object
    pub id: Id,

    /// String representing the object's type
    pub object: String,

    /// Define thresholds at which an invoice will be sent, and the related subscription advanced to a new billing period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_thresholds: Option<SubscriptionItemBillingThresholds>,

    /// Time at which the object was created
    pub created: Timestamp,

    /// Set of key-value pairs attached to the object
    #[serde(default)]
    pub metadata: Metadata,

    /// The plan the customer is subscribed to
    pub plan: Plan,

    /// ID of the price associated with this subscription item
    pub price: Id,

    /// The quantity of the plan to which the customer should be subscribed
    pub quantity: i64,

    /// The subscription this subscription item belongs to
    pub subscription: Id,
}

/// Define thresholds at which an invoice will be sent, and the related subscription advanced to a new billing period
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct SubscriptionItemBillingThresholds {
    /// Usage threshold that triggers the subscription to advance to a new billing period
    pub usage_gte: i64,
}

/// Hash describing the plan the customer is subscribed to
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Plan {
    /// Unique identifier for the object
    pub id: Id,

    /// String representing the object's type
    pub object: String,

    /// Whether the plan is currently available for new subscriptions
    pub active: bool,

    /// The currency in which the subscription will be charged
    pub currency: Currency,

    /// One of `day`, `week`, `month` or `year`
    pub interval: PlanInterval,

    /// The number of intervals between subscription billings
    pub interval_count: u32,

    /// Set of key-value pairs attached to the object
    #[serde(default)]
    pub metadata: Metadata,

    /// Nickname for the plan
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nickname: Option<String>,

    /// The ID of the product whose pricing this plan represents
    pub product: Id,

    /// Each element represents a pricing tier
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tiers: Option<Vec<PlanTier>>,

    /// Defines if the tiering price should be `graduated` or `volume` based
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tiers_mode: Option<TiersMode>,

    /// Apply a transformation to the reported usage or set quantity before computing the billed price
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transform_usage: Option<TransformUsage>,

    /// The unit amount in the currency's smallest unit to be charged, unless a tier price applies
    pub unit_amount: i64,

    /// Same as unit_amount, but contains a decimal value
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit_amount_decimal: Option<String>,

    /// When the subscription will be billed
    pub billing_scheme: BillingScheme,
}

/// One of `day`, `week`, `month` or `year`
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PlanInterval {
    /// Daily billing
    Day,

    /// Weekly billing
    Week,

    /// Monthly billing
    Month,

    /// Yearly billing
    Year,
}

/// Pricing tier
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct PlanTier {
    /// Per unit price for units in this tier
    pub unit_amount: i64,

    /// Same as unit_amount, but contains a decimal value
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit_amount_decimal: Option<String>,

    /// Up to and including this quantity will be contained in the tier
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_to: Option<i64>,

    /// Price for the entire tier
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flat_amount: Option<i64>,

    /// Same as flat_amount, but contains a decimal value
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flat_amount_decimal: Option<String>,
}

/// Defines if the tiering price should be `graduated` or `volume` based
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum TiersMode {
    /// Apply tier pricing to the total quantity
    Graduated,

    /// Apply tier pricing independently per group of quantities
    Volume,
}

/// Apply a transformation to the reported usage or set quantity before computing the billed price
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TransformUsage {
    /// Divide usage by this number
    pub divide_by: i64,

    /// After division, either round the result `up` or `down`
    pub round: RoundingMode,
}

/// After division, either round the result `up` or `down`
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum RoundingMode {
    /// Round up to the nearest integer
    Up,

    /// Round down to the nearest integer
    Down,
}

/// When the subscription will be billed
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum BillingScheme {
    /// The subscription's price is a fixed amount
    PerUnit,

    /// The subscription's price can vary based on usage
    Tiered,
}

/// Describes the current status of the subscription
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SubscriptionStatus {
    /// The subscription is active and will be automatically charged in the future
    Active,

    /// The most recent invoice hasn't been paid but the subscription remains in good standing
    PastDue,

    /// The subscription is created but awaiting an invoice to be paid
    Unpaid,

    /// The subscription is canceled and will end after the current period
    Canceled,

    /// The subscription has ended
    Ended,

    /// The subscription is incomplete and will not start until successful payment
    Incomplete,

    /// The initial payment on the subscription failed and it will be retried
    IncompleteExpired,

    /// The subscription is paused and will not be billed until resumed
    Paused,

    /// The subscription is currently within its trial period
    Trialing,
}

/// Updates to a subscription item
#[derive(Debug, Serialize, Clone)]
pub struct SubscriptionItemUpdateParams {
    /// The ID of the subscription item to modify
    pub id: String,

    /// The ID of the price used for this subscription item
    #[serde(skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,

    /// The plan to which the customer should be subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plan: Option<String>,

    /// The quantity of the plan to which the customer should be subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quantity: Option<i64>,

    /// Determines how to handle prorations resulting from the subscription item
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proration_behavior: Option<ProrationBehavior>,
}

/// Determines how to handle prorations resulting from a subscription change
#[derive(Debug, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ProrationBehavior {
    /// Always create prorations
    CreateProrations,

    /// Create prorations when adding new subscription items
    AlwaysInvoice,

    /// Don't create prorations
    None,
}

/// Parameters for creating a new subscription
#[derive(Debug, Serialize, Clone)]
pub struct CreateSubscription {
    /// The identifier of the customer to subscribe
    pub customer: String,

    /// The list of items the customer is subscribing to
    pub items: Vec<SubscriptionItemParams>,

    /// Whether the subscription should be scheduled for cancellation at the end of the current period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancel_at_period_end: Option<bool>,

    /// The subscription's description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// A future timestamp to terminate the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancel_at: Option<i64>,

    /// The tax rates that will apply to any subscription item that does not have tax_rates set
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_tax_rates: Option<Vec<String>>,

    /// ID of the default payment method for the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_payment_method: Option<String>,

    /// Number of days a customer has to pay invoices generated by this subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_until_due: Option<i64>,

    /// Set of key-value pairs attached to the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,

    /// When the subscription should start
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_cycle_anchor: Option<i64>,

    /// When to create prorations for the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proration_behavior: Option<ProrationBehavior>,

    /// Trial period in days
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trial_period_days: Option<i64>,

    /// End of the trial period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trial_end: Option<i64>,

    /// Either `charge_automatically`, or `send_invoice`
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing: Option<BillingType>,
}

/// Parameters for a subscription item
#[derive(Debug, Serialize, Clone)]
pub struct SubscriptionItemParams {
    /// The ID of the price used for this subscription item
    pub price: String,

    /// The quantity of the plan to which the customer should be subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quantity: Option<i64>,

    /// Set of key-value pairs attached to the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,

    /// The tax rates which apply to this subscription item
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tax_rates: Option<Vec<String>>,
}

/// Parameters for updating a subscription
#[derive(Debug, Serialize, Default, Clone)]
pub struct UpdateSubscription {
    /// The list of items the customer is subscribing to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<SubscriptionItemUpdateParams>>,

    /// Whether the subscription should be scheduled for cancellation at the end of the current period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancel_at_period_end: Option<bool>,

    /// The subscription's description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// A future timestamp to terminate the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancel_at: Option<i64>,

    /// The tax rates that will apply to any subscription item that does not have tax_rates set
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_tax_rates: Option<Vec<String>>,

    /// ID of the default payment method for the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_payment_method: Option<String>,

    /// Number of days a customer has to pay invoices generated by this subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_until_due: Option<i64>,

    /// Set of key-value pairs attached to the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,

    /// When to create prorations for the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proration_behavior: Option<ProrationBehavior>,

    /// End of the trial period
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trial_end: Option<i64>,

    /// Either `charge_automatically`, or `send_invoice`
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing: Option<BillingType>,
}

/// Subscription API implementation
impl Client {
    /// Create a new subscription
    pub async fn create_subscription(&self, params: &CreateSubscription) -> Result<Subscription> {
        let url = format!("{}/subscriptions", self.base_url());
        let response = self.http_client().post(&url).json(params).send().await?;

        let status = response.status();
        if !status.is_success() {
            let error: crate::error::ApiError = response.json().await?;
            return Err(error.into());
        }

        let subscription: Subscription = response.json().await?;
        Ok(subscription)
    }

    /// Retrieve a subscription by ID
    pub async fn get_subscription(&self, subscription_id: &str) -> Result<Subscription> {
        let url = format!("{}/subscriptions/{}", self.base_url(), subscription_id);
        let response = self.http_client().get(&url).send().await?;

        let status = response.status();
        if !status.is_success() {
            let error: crate::error::ApiError = response.json().await?;
            return Err(error.into());
        }

        let subscription: Subscription = response.json().await?;
        Ok(subscription)
    }

    /// Update a subscription by ID
    pub async fn update_subscription(
        &self,
        subscription_id: &str,
        params: &UpdateSubscription,
    ) -> Result<Subscription> {
        let url = format!("{}/subscriptions/{}", self.base_url(), subscription_id);
        let response = self.http_client().post(&url).json(params).send().await?;

        let status = response.status();
        if !status.is_success() {
            let error: crate::error::ApiError = response.json().await?;
            return Err(error.into());
        }

        let subscription: Subscription = response.json().await?;
        Ok(subscription)
    }

    /// Cancel a subscription
    pub async fn cancel_subscription(
        &self,
        subscription_id: &str,
        cancel_at_period_end: bool,
    ) -> Result<Subscription> {
        let url = format!("{}/subscriptions/{}", self.base_url(), subscription_id);
        let response = self
            .http_client()
            .delete(&url)
            .query(&[("cancel_at_period_end", cancel_at_period_end.to_string())])
            .send()
            .await?;

        let status = response.status();
        if !status.is_success() {
            let error: crate::error::ApiError = response.json().await?;
            return Err(error.into());
        }

        let subscription: Subscription = response.json().await?;
        Ok(subscription)
    }

    /// List all subscriptions
    pub async fn list_subscriptions(
        &self,
        limit: Option<u32>,
        customer: Option<&str>,
        status: Option<SubscriptionStatus>,
    ) -> Result<List<Subscription>> {
        let mut url = format!("{}/subscriptions", self.base_url());

        let mut query_params = Vec::new();

        if let Some(limit) = limit {
            query_params.push(format!("limit={}", limit));
        }

        if let Some(customer_id) = customer {
            query_params.push(format!("customer={}", customer_id));
        }

        if let Some(status) = status {
            let status_str = match status {
                SubscriptionStatus::Active => "active",
                SubscriptionStatus::PastDue => "past_due",
                SubscriptionStatus::Unpaid => "unpaid",
                SubscriptionStatus::Canceled => "canceled",
                SubscriptionStatus::Ended => "ended",
                SubscriptionStatus::Incomplete => "incomplete",
                SubscriptionStatus::IncompleteExpired => "incomplete_expired",
                SubscriptionStatus::Paused => "paused",
                SubscriptionStatus::Trialing => "trialing",
            };
            query_params.push(format!("status={}", status_str));
        }

        if !query_params.is_empty() {
            url = format!("{}?{}", url, query_params.join("&"));
        }

        let response = self.http_client().get(&url).send().await?;

        let status = response.status();
        if !status.is_success() {
            let error: crate::error::ApiError = response.json().await?;
            return Err(error.into());
        }

        let subscriptions: List<Subscription> = response.json().await?;
        Ok(subscriptions)
    }
}
