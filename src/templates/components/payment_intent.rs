//! Stripe Payment Intent API
//!
//! This module provides functionality to create, retrieve, update, and list payment intents.
//! Payment intents track the lifecycle of a customer payment.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use crate::stripe::client::Client;
use crate::stripe::error::Result;
use crate::stripe::types::{Currency, Id, List, Metadata, Timestamp};

/// A Stripe payment intent object
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct PaymentIntent {
    /// Unique identifier for the object
    pub id: Id,
    
    /// String representing the object's type
    pub object: String,
    
    /// Amount intended to be collected by this PaymentIntent (in smallest currency unit)
    pub amount: u64,
    
    /// Amount that can be captured from this PaymentIntent (in smallest currency unit)
    pub amount_capturable: u64,
    
    /// Amount that was collected by this PaymentIntent (in smallest currency unit)
    pub amount_received: u64,
    
    /// ID of the Connect application that created the PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application: Option<Id>,
    
    /// The amount of the application fee that will be requested for this payment
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_fee_amount: Option<u64>,
    
    /// Reason for cancellation of this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancellation_reason: Option<CancellationReason>,
    
    /// Status of this PaymentIntent's capture method
    pub capture_method: CaptureMethod,
    
    /// Time at which the object was created
    pub created: Timestamp,
    
    /// Three-letter ISO currency code
    pub currency: Currency,
    
    /// ID of the Customer this PaymentIntent belongs to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer: Option<Id>,
    
    /// An arbitrary string attached to the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    
    /// Payment-method-specific error if one occurred
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_payment_error: Option<PaymentError>,
    
    /// Has the value true if the object exists in live mode
    pub livemode: bool,
    
    /// Set of key-value pairs attached to the object
    #[serde(default)]
    pub metadata: Metadata,
    
    /// ID of the payment method used in this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payment_method: Option<Id>,
    
    /// The list of payment method types that this PaymentIntent is allowed to use
    pub payment_method_types: Vec<String>,
    
    /// Email address that the receipt for the resulting payment will be sent to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub receipt_email: Option<String>,
    
    /// Status of this PaymentIntent
    pub status: PaymentIntentStatus,
    
    /// The payment error encountered in the previous PaymentIntent confirmation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_setup_error: Option<PaymentError>,
    
    /// Indicates how the payment method is intended to be used in the future
    #[serde(skip_serializing_if = "Option::is_none")]
    pub setup_future_usage: Option<SetupFutureUsage>,
    
    /// ID of the SetupIntent that this PaymentIntent is linked to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub setup_future_intent: Option<Id>,
    
    /// Shipping information for this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shipping: Option<ShippingDetails>,
    
    /// For non-card charges, you can use this value as the complete description that appears on your customers' statements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statement_descriptor: Option<String>,
    
    /// Provides information about a card payment that customers see on their statements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statement_descriptor_suffix: Option<String>,
    
    /// Configuration for automatic payment methods
    #[serde(skip_serializing_if = "Option::is_none")]
    pub automatic_payment_methods: Option<AutomaticPaymentMethods>,
    
    /// ID of the latest charge generated by this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub latest_charge: Option<Id>,
    
    /// ID of the account (if any) for which the funds of the PaymentIntent are intended
    #[serde(skip_serializing_if = "Option::is_none")]
    pub on_behalf_of: Option<Id>,
    
    /// The URL to redirect your customer back to after they authenticate or cancel their payment
    #[serde(skip_serializing_if = "Option::is_none")]
    pub return_url: Option<String>,
    
    /// Indicates that you intend to make future payments with this PaymentIntent's payment method
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_data: Option<TransferData>,
    
    /// A string that identifies the resulting payment as part of a group
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_group: Option<String>,
    
    /// The client secret of this PaymentIntent (only available in response to create/update calls)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<String>,
}

/// Status of a payment intent
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PaymentIntentStatus {
    /// Ready to be confirmed
    RequiresPaymentMethod,
    
    /// Customer authentication required
    RequiresConfirmation,
    
    /// Requires action to complete the payment
    RequiresAction,
    
    /// Payment is processing
    Processing,
    
    /// Payment requires capture
    RequiresCapture,
    
    /// Payment is captured and completed
    Succeeded,
    
    /// Payment was canceled
    Canceled,
}

/// Reason for cancellation of a PaymentIntent
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum CancellationReason {
    /// Canceled due to duplicate payment
    Duplicate,
    
    /// Canceled by the merchant
    RequestedByCustomer,
    
    /// Canceled due to payment abandonment
    Abandoned,
    
    /// Canceled due to a failure in processing
    FailedInvoice,
    
    /// Canceled due to fraud detection
    Fraudulent,
    
    /// Canceled for another reason
    #[serde(other)]
    Other,
}

/// Capture method of a PaymentIntent
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum CaptureMethod {
    /// Capture automatically when authorized
    Automatic,
    
    /// Capture manually after authorization
    Manual,
}

/// Information about a payment error
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct PaymentError {
    /// The type of error
    #[serde(rename = "type")]
    pub type_: PaymentErrorType,
    
    /// The specific code for the error
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    
    /// A human-readable message providing more details about the error
    pub message: String,
    
    /// The parameter the error relates to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param: Option<String>,
    
    /// The payment method that caused the error
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payment_method: Option<Id>,
}

/// Type of payment error
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PaymentErrorType {
    /// Error related to the card
    CardError,
    
    /// Error related to the customer's payment method
    PaymentMethodError,
    
    /// Error related to a specific customer
    CustomerError,
    
    /// Error with the Stripe API
    ApiError,
    
    /// Invalid request error
    InvalidRequestError,
    
    /// Other error type
    #[serde(other)]
    Other,
}

/// How the payment method is intended to be used in the future
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SetupFutureUsage {
    /// Use for a single payment
    OnSession,
    
    /// Store for future payments
    OffSession,
}

/// Shipping details for the payment
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct ShippingDetails {
    /// Shipping address
    pub address: Address,
    
    /// The delivery service that shipped a physical product
    #[serde(skip_serializing_if = "Option::is_none")]
    pub carrier: Option<String>,
    
    /// Recipient name
    pub name: String,
    
    /// Recipient phone (including extension)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub phone: Option<String>,
    
    /// The tracking number for a physical product
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tracking_number: Option<String>,
}

/// An address
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct Address {
    /// City, district, suburb, town, or village
    #[serde(skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,
    
    /// Two-letter country code
    #[serde(skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    
    /// Address line 1 (e.g., street, PO Box, or company name)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line1: Option<String>,
    
    /// Address line 2 (e.g., apartment, suite, unit, or building)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line2: Option<String>,
    
    /// ZIP or postal code
    #[serde(skip_serializing_if = "Option::is_none")]
    pub postal_code: Option<String>,
    
    /// State, county, province, or region
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

/// Configuration for automatic payment methods
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct AutomaticPaymentMethods {
    /// Whether automatic payment methods are enabled
    pub enabled: bool,
    
    /// Allowed payment method types
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_payment_method_types: Option<Vec<String>>,
}

/// Transfer data for the payment intent
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct TransferData {
    /// The account that funds will be transferred to
    pub destination: Id,
    
    /// The amount to be transferred automatically when a charge succeeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amount: Option<u64>,
}

/// Parameters for creating a new payment intent
#[derive(Debug, Serialize, Default, Clone)]
pub struct CreatePaymentIntent {
    /// Amount intended to be collected by this PaymentIntent (in smallest currency unit)
    pub amount: u64,
    
    /// Three-letter ISO currency code
    pub currency: Currency,
    
    /// ID of the Customer this PaymentIntent belongs to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer: Option<String>,
    
    /// An arbitrary string attached to the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    
    /// Set of payment method types that this PaymentIntent is allowed to use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payment_method_types: Option<Vec<String>>,
    
    /// Email address that the receipt for the resulting payment will be sent to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub receipt_email: Option<String>,
    
    /// Indicates that you intend to make future payments with this PaymentIntent's payment method
    #[serde(skip_serializing_if = "Option::is_none")]
    pub setup_future_usage: Option<SetupFutureUsage>,
    
    /// Shipping information for this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shipping: Option<ShippingDetails>,
    
    /// For non-card charges, you can use this value as the complete description that appears on your customers' statements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statement_descriptor: Option<String>,
    
    /// Provides information about a card payment that customers see on their statements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statement_descriptor_suffix: Option<String>,
    
    /// The parameters used to automatically create a Transfer when the payment succeeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_group: Option<String>,
    
    /// Set to true to confirm the payment intent immediately
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confirm: Option<bool>,
    
    /// ID of the payment method to attach to this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payment_method: Option<String>,
    
    /// URL to redirect your customer back to after they authenticate or cancel their payment
    #[serde(skip_serializing_if = "Option::is_none")]
    pub return_url: Option<String>,
    
    /// Set of key-value pairs that you can attach to an object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,
    
    /// Controls when the funds will be captured from the customer's account
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capture_method: Option<CaptureMethod>,
    
    /// Set to true to enable automatic payment methods
    #[serde(skip_serializing_if = "Option::is_none")]
    pub automatic_payment_methods: Option<AutomaticPaymentMethods>,
    
    /// The amount of the application fee (if any) that will be requested for the payment
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_fee_amount: Option<u64>,
    
    /// Account that funds will be transferred to after payment completion
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_data: Option<TransferData>,
    
    /// The Stripe account ID for which the payment is intended
    #[serde(skip_serializing_if = "Option::is_none")]
    pub on_behalf_of: Option<String>,
}

/// Parameters for updating a payment intent
#[derive(Debug, Serialize, Default, Clone)]
pub struct UpdatePaymentIntent {
    /// Amount intended to be collected by this PaymentIntent (in smallest currency unit)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amount: Option<u64>,
    
    /// Three-letter ISO currency code
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currency: Option<Currency>,
    
    /// ID of the Customer this PaymentIntent belongs to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer: Option<String>,
    
    /// An arbitrary string attached to the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    
    /// Set of payment method types that this PaymentIntent is allowed to use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payment_method_types: Option<Vec<String>>,
    
    /// Email address that the receipt for the resulting payment will be sent to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub receipt_email: Option<String>,
    
    /// Indicates that you intend to make future payments with this PaymentIntent's payment method
    #[serde(skip_serializing_if = "Option::is_none")]
    pub setup_future_usage: Option<SetupFutureUsage>,
    
    /// Shipping information for this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shipping: Option<ShippingDetails>,
    
    /// Set of key-value pairs that you can attach to an object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,
    
    /// ID of the payment method to attach to this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payment_method: Option<String>,
    
    /// Transfer data for direct charges
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_data: Option<TransferData>,
}

/// Parameters for confirming a payment intent
#[derive(Debug, Serialize, Default, Clone)]
pub struct ConfirmPaymentIntent {
    /// ID of the payment method to attach to this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payment_method: Option<String>,
    
    /// URL to redirect your customer back to after they authenticate or cancel their payment
    #[serde(skip_serializing_if = "Option::is_none")]
    pub return_url: Option<String>,
    
    /// Set to true if you intend to use this PaymentIntent's payment method for future payments
    #[serde(skip_serializing_if = "Option::is_none")]
    pub setup_future_usage: Option<SetupFutureUsage>,
    
    /// Shipping information for this PaymentIntent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shipping: Option<ShippingDetails>,
    
    /// Email address to send the receipt to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub receipt_email: Option<String>,
    
    /// Controls when the funds will be captured from the customer's account
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capture_method: Option<CaptureMethod>,
}

/// Parameters for capturing a payment intent
#[derive(Debug, Serialize, Default, Clone)]
pub struct CapturePaymentIntent {
    /// The amount to capture from the payment intent, in the smallest currency unit
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amount_to_capture: Option<u64>,
    
    /// The application fee amount to apply to this capture
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_fee_amount: Option<u64>,
    
    /// Set of key-value pairs that you can attach to an object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,
    
    /// For non-card charges, you can use this value as the complete description that appears on your customers' statements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statement_descriptor: Option<String>,
    
    /// An additional statement descriptor appended to the statement descriptor
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statement_descriptor_suffix: Option<String>,
    
    /// The amount of the application fee (if any) that will be requested for the payment 
    /// or the difference between the amount of the application fee that was requested 
    /// for the payment and the amount already refunded
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_data: Option<TransferData>,
}

/// Payment Intent API implementation
impl Client {
    /// Create a new payment intent
    pub async fn create_payment_intent(&self, params: &CreatePaymentIntent) -> Result<PaymentIntent> {
        let url = format!("{}/payment_intents", self.base_url());
        let response = self.http_client()
            .post(&url)
            .json(params)
            .send()
            .await?;
        
        let status = response.status();
        if !status.is_success() {
            let error: crate::stripe::error::ApiError = response.json().await?;
            return Err(error.into());
        }
        
        let payment_intent: PaymentIntent = response.json().await?;
        Ok(payment_intent)
    }
    
    /// Retrieve a payment intent by ID
    pub async fn get_payment_intent(&self, payment_intent_id: &str) -> Result<PaymentIntent> {
        let url = format!("{}/payment_intents/{}", self.base_url(), payment_intent_id);
        let response = self.http_client()
            .get(&url)
            .send()
            .await?;
        
        let status = response.status();
        if !status.is_success() {
            let error: crate::stripe::error::ApiError = response.json().await?;
            return Err(error.into());
        }
        
        let payment_intent: PaymentIntent = response.json().await?;
        Ok(payment_intent)
    }
    
    /// Update a payment intent by ID
    pub async fn update_payment_intent(&self, payment_intent_id: &str, params: &UpdatePaymentIntent) -> Result<PaymentIntent> {
        let url = format!("{}/payment_intents/{}", self.base_url(), payment_intent_id);
        let response = self.http_client()
            .post(&url)
            .json(params)
            .send()
            .await?;
        
        let status = response.status();
        if !status.is_success() {
            let error: crate::stripe::error::ApiError = response.json().await?;
            return Err(error.into());
        }
        
        let payment_intent: PaymentIntent = response.json().await?;
        Ok(payment_intent)
    }
    
    /// Confirm a payment intent
    pub async fn confirm_payment_intent(&self, payment_intent_id: &str, params: Option<&ConfirmPaymentIntent>) -> Result<PaymentIntent> {
        let url = format!("{}/payment_intents/{}/confirm", self.base_url(), payment_intent_id);
        let mut request = self.http_client().post(&url);
        
        if let Some(params) = params {
            request = request.json(params);
        }
        
        let response = request.send().await?;
        
        let status = response.status();
        if !status.is_success() {
            let error: crate::stripe::error::ApiError = response.json().await?;
            return Err(error.into());
        }
        
        let payment_intent: PaymentIntent = response.json().await?;
        Ok(payment_intent)
    }
    
    /// Capture a payment intent
    pub async fn capture_payment_intent(&self, payment_intent_id: &str, params: Option<&CapturePaymentIntent>) -> Result<PaymentIntent> {
        let url = format!("{}/payment_intents/{}/capture", self.base_url(), payment_intent_id);
        let mut request = self.http_client().post(&url);
        
        if let Some(params) = params {
            request = request.json(params);
        }
        
        let response = request.send().await?;
        
        let status = response.status();
        if !status.is_success() {
            let error: crate::stripe::error::ApiError = response.json().await?;
            return Err(error.into());
        }
        
        let payment_intent: PaymentIntent = response.json().await?;
        Ok(payment_intent)
    }
    
    /// Cancel a payment intent
    pub async fn cancel_payment_intent(&self, payment_intent_id: &str, cancellation_reason: Option<CancellationReason>) -> Result<PaymentIntent> {
        let url = format!("{}/payment_intents/{}/cancel", self.base_url(), payment_intent_id);
        
        let mut request = self.http_client().post(&url);
        
        if let Some(reason) = cancellation_reason {
            request = request.json(&serde_json::json!({
                "cancellation_reason": reason
            }));
        }
        
        let response = request.send().await?;
        
        let status = response.status();
        if !status.is_success() {
            let error: crate::stripe::error::ApiError = response.json().await?;
            return Err(error.into());
        }
        
        let payment_intent: PaymentIntent = response.json().await?;
        Ok(payment_intent)
    }
    
    /// List all payment intents
    pub async fn list_payment_intents(&self, limit: Option<u32>, customer: Option<&str>) -> Result<List<PaymentIntent>> {
        let mut url = format!("{}/payment_intents", self.base_url());
        
        // Add query parameters
        let mut params = Vec::new();
        
        if let Some(limit) = limit {
            params.push(format!("limit={}", limit));
        }
        
        if let Some(customer) = customer {
            params.push(format!("customer={}", customer));
        }
        
        if !params.is_empty() {
            url = format!("{}?{}", url, params.join("&"));
        }
        
        let response = self.http_client()
            .get(&url)
            .send()
            .await?;
        
        let status = response.status();
        if !status.is_success() {
            let error: crate::stripe::error::ApiError = response.json().await?;
            return Err(error.into());
        }
        
        let payment_intents: List<PaymentIntent> = response.json().await?;
        Ok(payment_intents)
    }
}